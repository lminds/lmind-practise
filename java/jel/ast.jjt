options {
  STATIC=false;
  MULTI=false;
  NODE_PREFIX="Jel";
  NODE_PACKAGE="org.lmind.jel.core.ast";
  NODE_FACTORY="JelNodeFactory";
  NODE_CLASS="JelNode";
  BUILD_NODE_FILES=false;
}

PARSER_BEGIN(JelParser)
package org.lmind.jel.core.ast;

/** Simple brace matcher. */
public class JelParser {


}

PARSER_END(JelParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (["f","F","d","D"])?
      | "." (["0"-"9"])+  (["f","F","d","D"])?
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
			| ["u"] ["0"-"9"] ( ["0"-"9"] )*
            )
          )
      )*
      "\""
  >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039"
      ]
  >
}

void BooleanLiteral() :
{
  Token t;
}
{
  t="true"
  {
    jjtThis.setImage(t.image);
  }
|
  t="false"
  {
    jjtThis.setImage(t.image);
  }
}

void NullLiteral() :
{}
{
  "null"
}

void StringLiteral() :
{
  Token t;
}
{
  t=<STRING_LITERAL>
  {
    jjtThis.setImage(t.image);
  }
}

void NumberLiteral() :
{
  Token t;
}
{
  t=<INTEGER_LITERAL>
  {
    jjtThis.setImage(t.image);
  }
|
  t=<FLOATING_POINT_LITERAL>
  {
    jjtThis.setImage(t.image);
  }
}

void Literal() #void :
{}
{
  NumberLiteral()
|
  StringLiteral()
|
  BooleanLiteral()
|
  NullLiteral()
}

void Identifier() :
{
  Token t;
}
{
  t=<IDENTIFIER>
  {
    jjtThis.setImage(t.image);
  }
}


/** Root production. */
JelNode Expression() :
{}
{
  ExpressionTerm() <EOF>
  { return jjtThis; }
}

/*
 * Expression syntax follows.
 */

void ExpressionTerm() #void :
{}
{
  TernaryExpression()
}

void TernaryExpression() :
{}
{
  ConditionalOrExpression() [ "?" ExpressionTerm() ":" TernaryExpression() ]
}

void ConditionalOrExpression() :
{}
{
  ConditionalAndExpression() ( "||" ConditionalAndExpression() )*
}

void ConditionalAndExpression() :
{}
{
  EqualityExpression() ( "&&" EqualityExpression() )*
}

void EqualityExpression() :
{}
{
  RelationalExpression() ( ( "==" | "!=" ) RelationalExpression() )*
}

void RelationalExpression() :
{
  Token t;
}
{
  AdditiveExpression()
  (
    (t="<" | t=">" | t="<=" | t=">=" ) RelationalExpression()
	{
	  jjtThis.setImage(t.image);
	}
  )?
}

void AdditiveExpression() :
{
  Token t;
}
{
  MultiplicativeExpression()
  (
    ( t="+" | t="-" ) AdditiveExpression()
	{
	  jjtThis.setImage(t.image);
	}
  )?
}

void MultiplicativeExpression() :
{
  Token t;
}
{
  UnaryExpressionSign()
  (
    ( t="*" | t="/" | t="%" ) MultiplicativeExpression()
	{
	  jjtThis.setImage(t.image);
	}
  )?
}

void UnaryExpressionSign() :
{
  Token t;
}
{
  ( t="+" | t="-" ) UnaryExpressionSign()
  {
    jjtThis.setImage(t.image);
  }
|
  UnaryExpressionNot()
}

void UnaryExpressionNot() :
{
  Token t;
}
{
  t="!"  UnaryExpressionNot()
  {
    jjtThis.setImage(t.image);
  }
|
  InvocationExpression()
}

void InvocationExpression() :
{}
{
  PrimaryExpression() (
    LOOKAHEAD(2)(
	  InvokeExpression() | 
	  IndexProperty()))*
}

void IndexProperty() :
{}
{
  "[" ExpressionTerm() "]"
}

void InvokeExpression() :
{}
{
  "(" (ExpressionTerm() ( "," ExpressionTerm() )*)? ")"
}

void InvokeParamExpression() :
{}
{
  ExpressionTerm() ( "," ExpressionTerm() )*
}

void PrimaryExpression() #void :
{}
{
  "(" ExpressionTerm() ")"
|
  Reference()
|
  Literal()
}

// 对象引用
void Reference() :
{}
{
  Identifier() (MemberAccess() )*
}

void MemberAccess() :
{}
{
   "." Identifier()
}




